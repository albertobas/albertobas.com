---
field: 'data-visualization'
title: 'Predicting Ames housing prices: exploratory data analysis'
description: 'Exploratory data analysis on the Ames housing prices dataset'
introduction: "<p>An exploratory analysis is introduced in this notebook in order to come up with a good understanding of the Ames housing prices dataset. I'll make use of two simple forms of exploratory data visualizations: distribution (or distribution-based) plots and two-variable visualizations.</p><p>I am interested in knowing the shape of the data and the relations between the independent variables and the response. This visual exercise may enlighten us to insights and patterns which otherwise could have been harder to comprehend.</p>"
tags: 'univariate-analysis,bivariate-analysis,exploratory-data-analysis'
tech: 'python,jupyter,numpy,pandas,matplotlib,seaborn,scipy'
datePublished: '2022-03-01'
github: { repo: 'ames-housing-prices', file: 'ames_housing_prices_eda.ipynb' }
---

## Setup

```python
%%capture
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import warnings
from scipy.stats import boxcox, kurtosis, norm, probplot, skew
from sklearn.datasets import fetch_openml
from utils import plot_univariate, plot_bivariate
from IPython.display import display
pd.set_option('max_columns', 200)
warnings.filterwarnings('ignore')
sns.distributions._has_statsmodels=False # Estimating density with scipy
```

The dataset contains 79 values for every single observation, 80 in the training set considering the target value. There are 1460 observations in the training set and one less in the set that is used for testing the analysis, i.e., predicting the target variable, which is `SalePrice`. The only column that will not be used is `Id`.

```python
X_train = fetch_openml(name="house_prices", as_frame=True, data_home='data')['frame']
X_train.drop(['Id'], axis=1, inplace=True)
for col in ['MSSubClass', 'OverallQual', 'OverallCond']:
    X_train[col] = X_train[col].astype('int')
display(X_train.head(2), X_train.shape)
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>MSSubClass</th>
      <th>MSZoning</th>
      <th>LotFrontage</th>
      <th>LotArea</th>
      <th>Street</th>
      <th>Alley</th>
      <th>LotShape</th>
      <th>LandContour</th>
      <th>Utilities</th>
      <th>LotConfig</th>
      <th>LandSlope</th>
      <th>Neighborhood</th>
      <th>Condition1</th>
      <th>Condition2</th>
      <th>BldgType</th>
      <th>HouseStyle</th>
      <th>OverallQual</th>
      <th>OverallCond</th>
      <th>YearBuilt</th>
      <th>YearRemodAdd</th>
      <th>RoofStyle</th>
      <th>RoofMatl</th>
      <th>Exterior1st</th>
      <th>Exterior2nd</th>
      <th>MasVnrType</th>
      <th>MasVnrArea</th>
      <th>ExterQual</th>
      <th>ExterCond</th>
      <th>Foundation</th>
      <th>BsmtQual</th>
      <th>BsmtCond</th>
      <th>BsmtExposure</th>
      <th>BsmtFinType1</th>
      <th>BsmtFinSF1</th>
      <th>BsmtFinType2</th>
      <th>BsmtFinSF2</th>
      <th>BsmtUnfSF</th>
      <th>TotalBsmtSF</th>
      <th>Heating</th>
      <th>HeatingQC</th>
      <th>CentralAir</th>
      <th>Electrical</th>
      <th>1stFlrSF</th>
      <th>2ndFlrSF</th>
      <th>LowQualFinSF</th>
      <th>GrLivArea</th>
      <th>BsmtFullBath</th>
      <th>BsmtHalfBath</th>
      <th>FullBath</th>
      <th>HalfBath</th>
      <th>BedroomAbvGr</th>
      <th>KitchenAbvGr</th>
      <th>KitchenQual</th>
      <th>TotRmsAbvGrd</th>
      <th>Functional</th>
      <th>Fireplaces</th>
      <th>FireplaceQu</th>
      <th>GarageType</th>
      <th>GarageYrBlt</th>
      <th>GarageFinish</th>
      <th>GarageCars</th>
      <th>GarageArea</th>
      <th>GarageQual</th>
      <th>GarageCond</th>
      <th>PavedDrive</th>
      <th>WoodDeckSF</th>
      <th>OpenPorchSF</th>
      <th>EnclosedPorch</th>
      <th>3SsnPorch</th>
      <th>ScreenPorch</th>
      <th>PoolArea</th>
      <th>PoolQC</th>
      <th>Fence</th>
      <th>MiscFeature</th>
      <th>MiscVal</th>
      <th>MoSold</th>
      <th>YrSold</th>
      <th>SaleType</th>
      <th>SaleCondition</th>
      <th>SalePrice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>60</td>
      <td>RL</td>
      <td>65.0</td>
      <td>8450.0</td>
      <td>Pave</td>
      <td>None</td>
      <td>Reg</td>
      <td>Lvl</td>
      <td>AllPub</td>
      <td>Inside</td>
      <td>Gtl</td>
      <td>CollgCr</td>
      <td>Norm</td>
      <td>Norm</td>
      <td>1Fam</td>
      <td>2Story</td>
      <td>7</td>
      <td>5</td>
      <td>2003.0</td>
      <td>2003.0</td>
      <td>Gable</td>
      <td>CompShg</td>
      <td>VinylSd</td>
      <td>VinylSd</td>
      <td>BrkFace</td>
      <td>196.0</td>
      <td>Gd</td>
      <td>TA</td>
      <td>PConc</td>
      <td>Gd</td>
      <td>TA</td>
      <td>No</td>
      <td>GLQ</td>
      <td>706.0</td>
      <td>Unf</td>
      <td>0.0</td>
      <td>150.0</td>
      <td>856.0</td>
      <td>GasA</td>
      <td>Ex</td>
      <td>Y</td>
      <td>SBrkr</td>
      <td>856.0</td>
      <td>854.0</td>
      <td>0.0</td>
      <td>1710.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>Gd</td>
      <td>8.0</td>
      <td>Typ</td>
      <td>0.0</td>
      <td>None</td>
      <td>Attchd</td>
      <td>2003.0</td>
      <td>RFn</td>
      <td>2.0</td>
      <td>548.0</td>
      <td>TA</td>
      <td>TA</td>
      <td>Y</td>
      <td>0.0</td>
      <td>61.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>0.0</td>
      <td>2.0</td>
      <td>2008.0</td>
      <td>WD</td>
      <td>Normal</td>
      <td>208500.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>20</td>
      <td>RL</td>
      <td>80.0</td>
      <td>9600.0</td>
      <td>Pave</td>
      <td>None</td>
      <td>Reg</td>
      <td>Lvl</td>
      <td>AllPub</td>
      <td>FR2</td>
      <td>Gtl</td>
      <td>Veenker</td>
      <td>Feedr</td>
      <td>Norm</td>
      <td>1Fam</td>
      <td>1Story</td>
      <td>6</td>
      <td>8</td>
      <td>1976.0</td>
      <td>1976.0</td>
      <td>Gable</td>
      <td>CompShg</td>
      <td>MetalSd</td>
      <td>MetalSd</td>
      <td>None</td>
      <td>0.0</td>
      <td>TA</td>
      <td>TA</td>
      <td>CBlock</td>
      <td>Gd</td>
      <td>TA</td>
      <td>Gd</td>
      <td>ALQ</td>
      <td>978.0</td>
      <td>Unf</td>
      <td>0.0</td>
      <td>284.0</td>
      <td>1262.0</td>
      <td>GasA</td>
      <td>Ex</td>
      <td>Y</td>
      <td>SBrkr</td>
      <td>1262.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1262.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>TA</td>
      <td>6.0</td>
      <td>Typ</td>
      <td>1.0</td>
      <td>TA</td>
      <td>Attchd</td>
      <td>1976.0</td>
      <td>RFn</td>
      <td>2.0</td>
      <td>460.0</td>
      <td>TA</td>
      <td>TA</td>
      <td>Y</td>
      <td>298.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>0.0</td>
      <td>5.0</td>
      <td>2007.0</td>
      <td>WD</td>
      <td>Normal</td>
      <td>181500.0</td>
    </tr>
  </tbody>
</DataFrame>

<CellOut>```(1460, 80) ```</CellOut>

Input variables have been classified by their levels of measurement (ratio, interval, ordinal, nominal):

```python
verbal = [f for f in X_train.columns if X_train.dtypes[f] == 'object']
numerical = [f for f in X_train.columns if X_train.dtypes[f] != 'object']
qualitative = verbal + ['MSSubClass', 'OverallQual', 'OverallCond']
quantitative = [n for n in numerical if n not in qualitative and n != 'SalePrice']
interval = ['GarageYrBlt', 'YearBuilt', 'YearRemodAdd', 'YrSold', 'MoSold']
ratio = [c for c in quantitative if c not in interval and c != 'SalePrice']
ratio.sort()
ordinal = ['LotShape', 'Utilities', 'LandSlope', 'ExterQual', 'OverallQual', 'OverallCond',
           'ExterCond', 'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2',
           'HeatingQC', 'Electrical', 'KitchenQual', 'Functional', 'FireplaceQu',
           'GarageFinish', 'GarageQual', 'GarageCond', 'PavedDrive', 'PoolQC', 'Fence']
ordinal.sort()
nominal = [n for n in qualitative if n not in ordinal]
nominal.sort()
```

## The response: `SalePrice`

The plots on the left-hand side of the following figure show the distribution of all the prices that I will
use to supervise the analysis and the probability plot of all this samples.

We can see positive skewness and kurtosis, there is a long tail to the right and the distribution is very peaked around the mean, so our response does not follow a normal distribution (shown in black).

However, this is partially rectified after a log-transformation as can be seen in the probability and distribution plots on the right-hand side: the distribution follows the diagonal closely in the corresponding probabilty plot and the density is closer to the normal shape.

```python
sns.set(font_scale=1.35, style='dark');
fig = plt.figure(figsize=(17,9));
plt.subplots_adjust(hspace=.3);
title = ['SalePrice', 'log(SalePrice)']
for i, y in enumerate([X_train['SalePrice'], np.log(X_train['SalePrice'])]*2, start=1):
    ax = plt.subplot(2, 2, i);
    if i<3:
        sns.distplot(y, fit=norm, ax=ax);
        ax.legend(['Normal distribution', 'Skewness: {:.3}\nKurtosis: {:.3}'.format(y.skew(),
                                                                                    y.kurt())],
                  loc='best');
        ax.set_title(title[i-1], fontdict={'fontweight':'bold'})
        ax.set_xlabel(title[i-1])
    else:
        probplot(y, plot=ax);
        ax.get_lines()[0].set_markerfacecolor('#7b9ece')
plt.show()
```

<Image alt="SalePrice and log(SalePrice) probability and distribution plots" src="/images/ames-housing-prices-eda/output_7_0.png" width={1040} height={564} />

```python
X_train[['SalePrice']].describe()
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>SalePrice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1460.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>180921.195890</td>
    </tr>
    <tr>
      <th>std</th>
      <td>79442.502883</td>
    </tr>
    <tr>
      <th>min</th>
      <td>34900.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>129975.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>163000.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>214000.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>755000.000000</td>
    </tr>
  </tbody>
</DataFrame>

## The predictors

A graphical analysis will be performed first, looking at the predictors one by one, and then at the plots of the predictors as a function of the response. The figures are classified by level of measurement: ratio, interval, ordinal and nominal. I'll be using this [two functions](utils/eda.py 'EDA functions') to plot the graphics.

### Univariate analysis

This analysis is helpful to find out some particularities in the data:

- The vast majority of houses have less than 2000 square feet above grade living area and less than 20000 square feet of lot area.

- The distribution plot of `TotalBsmtSF` shows that most of the houses have a basement.

- Most of the houses have between 5 and 7 rooms above grade, nonetheless, there are houses with up to 14 rooms above grade.

- There are a few houses with more than one kitchen above grade and some without bedrooms.

- Most of the properties have either 1 or 2 full baths but there are a few with 3 and some others without full bathrooms.

- Most of the properties have enough space for up to two cars in the garage.

- Most of the houses do not have a pool nor a porch.

```python
# Ratio-measured variables
X_train[ratio].describe()
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>1stFlrSF</th>
      <th>2ndFlrSF</th>
      <th>3SsnPorch</th>
      <th>BedroomAbvGr</th>
      <th>BsmtFinSF1</th>
      <th>BsmtFinSF2</th>
      <th>BsmtFullBath</th>
      <th>BsmtHalfBath</th>
      <th>BsmtUnfSF</th>
      <th>EnclosedPorch</th>
      <th>Fireplaces</th>
      <th>FullBath</th>
      <th>GarageArea</th>
      <th>GarageCars</th>
      <th>GrLivArea</th>
      <th>HalfBath</th>
      <th>KitchenAbvGr</th>
      <th>LotArea</th>
      <th>LotFrontage</th>
      <th>LowQualFinSF</th>
      <th>MasVnrArea</th>
      <th>MiscVal</th>
      <th>OpenPorchSF</th>
      <th>PoolArea</th>
      <th>ScreenPorch</th>
      <th>TotRmsAbvGrd</th>
      <th>TotalBsmtSF</th>
      <th>WoodDeckSF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1201.000000</td>
      <td>1460.000000</td>
      <td>1452.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1162.626712</td>
      <td>346.992466</td>
      <td>3.409589</td>
      <td>2.866438</td>
      <td>443.639726</td>
      <td>46.549315</td>
      <td>0.425342</td>
      <td>0.057534</td>
      <td>567.240411</td>
      <td>21.954110</td>
      <td>0.613014</td>
      <td>1.565068</td>
      <td>472.980137</td>
      <td>1.767123</td>
      <td>1515.463699</td>
      <td>0.382877</td>
      <td>1.046575</td>
      <td>10516.828082</td>
      <td>70.049958</td>
      <td>5.844521</td>
      <td>103.685262</td>
      <td>43.489041</td>
      <td>46.660274</td>
      <td>2.758904</td>
      <td>15.060959</td>
      <td>6.517808</td>
      <td>1057.429452</td>
      <td>94.244521</td>
    </tr>
    <tr>
      <th>std</th>
      <td>386.587738</td>
      <td>436.528436</td>
      <td>29.317331</td>
      <td>0.815778</td>
      <td>456.098091</td>
      <td>161.319273</td>
      <td>0.518911</td>
      <td>0.238753</td>
      <td>441.866955</td>
      <td>61.119149</td>
      <td>0.644666</td>
      <td>0.550916</td>
      <td>213.804841</td>
      <td>0.747315</td>
      <td>525.480383</td>
      <td>0.502885</td>
      <td>0.220338</td>
      <td>9981.264932</td>
      <td>24.284752</td>
      <td>48.623081</td>
      <td>181.066207</td>
      <td>496.123024</td>
      <td>66.256028</td>
      <td>40.177307</td>
      <td>55.757415</td>
      <td>1.625393</td>
      <td>438.705324</td>
      <td>125.338794</td>
    </tr>
    <tr>
      <th>min</th>
      <td>334.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>334.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1300.000000</td>
      <td>21.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>2.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>882.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>2.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>223.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>334.500000</td>
      <td>1.000000</td>
      <td>1129.500000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>7553.500000</td>
      <td>59.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>5.000000</td>
      <td>795.750000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1087.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>3.000000</td>
      <td>383.500000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>477.500000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>480.000000</td>
      <td>2.000000</td>
      <td>1464.000000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>9478.500000</td>
      <td>69.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>25.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>6.000000</td>
      <td>991.500000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>1391.250000</td>
      <td>728.000000</td>
      <td>0.000000</td>
      <td>3.000000</td>
      <td>712.250000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>808.000000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>576.000000</td>
      <td>2.000000</td>
      <td>1776.750000</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>11601.500000</td>
      <td>80.000000</td>
      <td>0.000000</td>
      <td>166.000000</td>
      <td>0.000000</td>
      <td>68.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>7.000000</td>
      <td>1298.250000</td>
      <td>168.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>4692.000000</td>
      <td>2065.000000</td>
      <td>508.000000</td>
      <td>8.000000</td>
      <td>5644.000000</td>
      <td>1474.000000</td>
      <td>3.000000</td>
      <td>2.000000</td>
      <td>2336.000000</td>
      <td>552.000000</td>
      <td>3.000000</td>
      <td>3.000000</td>
      <td>1418.000000</td>
      <td>4.000000</td>
      <td>5642.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
      <td>215245.000000</td>
      <td>313.000000</td>
      <td>572.000000</td>
      <td>1600.000000</td>
      <td>15500.000000</td>
      <td>547.000000</td>
      <td>738.000000</td>
      <td>480.000000</td>
      <td>14.000000</td>
      <td>6110.000000</td>
      <td>857.000000</td>
    </tr>
  </tbody>
</DataFrame>

```python
# add '3SsnPorch', 'OpenPorchSF', 'ScreenPorch' below to check the rest of the variables with values for Porch
ratio_vars = ['BedroomAbvGr', 'EnclosedPorch', 'KitchenAbvGr', 'FullBath', 'GarageCars',
              'GrLivArea', 'LotArea', 'TotalBsmtSF', 'TotRmsAbvGrd']
plot_univariate(X_train, ratio_vars, 2.5, 3, 5, 2, sns.distplot)
```

<Image alt="Ratio variables distribution plots" src="/images/ames-housing-prices-eda/output_11_0.png" width={2110} height={1029} />

```python
plot_univariate(X_train, ratio_vars+['PoolArea'], 2, 3, 4, 2, sns.boxplot)
```

<Image alt="Ratio variables box plots" src="/images/ames-housing-prices-eda/output_12_0.png" width={1690} height={1114} />

- There are observations in `YearRemodAdd` from 1950 onwards and, given the huge difference in quantity from this year to the following fifty years, it is likely there is a lower bound in their values. Moreover, as new properties most likely do not need remodelling and `YearRemodAdd` does not contain missing values, many of the values, apart from those for the houses with `YearRemodAdd` of 1950, may have been somehow prescriptively imputed.

```python
# Interval-measured variables
X_train[interval].describe()
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>GarageYrBlt</th>
      <th>YearBuilt</th>
      <th>YearRemodAdd</th>
      <th>YrSold</th>
      <th>MoSold</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1379.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
      <td>1460.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1978.506164</td>
      <td>1971.267808</td>
      <td>1984.865753</td>
      <td>2007.815753</td>
      <td>6.321918</td>
    </tr>
    <tr>
      <th>std</th>
      <td>24.689725</td>
      <td>30.202904</td>
      <td>20.645407</td>
      <td>1.328095</td>
      <td>2.703626</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1900.000000</td>
      <td>1872.000000</td>
      <td>1950.000000</td>
      <td>2006.000000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1961.000000</td>
      <td>1954.000000</td>
      <td>1967.000000</td>
      <td>2007.000000</td>
      <td>5.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1980.000000</td>
      <td>1973.000000</td>
      <td>1994.000000</td>
      <td>2008.000000</td>
      <td>6.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2002.000000</td>
      <td>2000.000000</td>
      <td>2004.000000</td>
      <td>2009.000000</td>
      <td>8.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>2010.000000</td>
      <td>2010.000000</td>
      <td>2010.000000</td>
      <td>2010.000000</td>
      <td>12.000000</td>
    </tr>
  </tbody>
</DataFrame>

```python
interval_vars = ['YearBuilt', 'YearRemodAdd', 'GarageYrBlt']
plot_univariate(X_train, interval_vars, 1.8, 3, 3, 2, sns.distplot, bins=50)
```

<Image alt="Interval variables distribution plots" src="/images/ames-housing-prices-eda/output_15_0.png" width={1274} height={183} />

- Obviously, there is a tight relation between predictors as `GarageYrBlt` and `YearBuilt`, or `GarageArea` and `GarageCars`, however, given the fact that most of the houses have garage and the distribution of `GarageYrBlt` and `YearBuilt` is slightly different, it is likely that either the garage in many properties has been built later or that the garage unit and the house are separate properties and consequently both have most likely been built in different years.

```python
print("Number of houses with garage:",
      X_train[X_train['GarageArea']>0].shape[0],
      "\nNumber of houses built the same year as the garage:",
      X_train[(X_train['GarageArea']>0) &
              (X_train['YearBuilt']==X_train['GarageYrBlt'])].shape[0])
```

<CellOut>
```
Number of houses with garage: 1379
Number of houses built the same year as the garage: 1089
```

</CellOut>

- There have been many more houses sold during the summer season. Also, the number of houses sold from year to year since 2006 has not changed vastly except for 2010, however, this is because the training set has records of houses that have been sold only until July 2010 as we can see below:

```python
interval_vars2 = ['MoSold', 'YrSold']
plot_univariate(X_train, interval_vars2, 1.4, 2, 3, 2, sns.barplot)
```

<Image alt="Interval variables bar plots" src="/images/ames-housing-prices-eda/output_19_0.png" width={842} height={194} />

```python
display(pd.DataFrame(X_train['YrSold'].value_counts()))
print("Last month with records in 2010: ", X_train[X_train['YrSold']==2010]['MoSold'].max())
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>YrSold</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2009.0</th>
      <td>338</td>
    </tr>
    <tr>
      <th>2007.0</th>
      <td>329</td>
    </tr>
    <tr>
      <th>2006.0</th>
      <td>314</td>
    </tr>
    <tr>
      <th>2008.0</th>
      <td>304</td>
    </tr>
    <tr>
      <th>2010.0</th>
      <td>175</td>
    </tr>
  </tbody>
</DataFrame>

<CellOut>
```
Last month with records in 2010: 7.0
```

</CellOut>

```python
# Nominal-measured variables
nominal_vars = ['BldgType', 'CentralAir', 'Heating', 'HouseStyle', 'LandContour', 'LotConfig',
                'MSZoning', 'MSSubClass', 'Neighborhood', 'SaleCondition', 'SaleType']
plot_univariate(X_train, nominal_vars, 1.6, 3, 3, 2, sns.barplot, labels_thresh=9, rotation=60)
```

<Image alt="Nominal variables bar plots" src="/images/ames-housing-prices-eda/output_21_0.png" width={1261} height={836} />

- The vast majority of houses have central air conditioning and also gas forced warm air furnaces as their type of heating.

- Most of the houses have been built in a residential area with low density.

```python
# Ordinal-measured variables
X_train['OverallCond'] = X_train['OverallCond'].astype('category')
X_train['OverallQual'] = X_train['OverallQual'].astype('category')
frame = X_train[ordinal].describe()
frame.index = ["count", 'unique', 'mode', 'freq']
display(frame)
X_train['OverallCond'] = X_train['OverallCond'].astype('int')
X_train['OverallQual'] = X_train['OverallQual'].astype('int')
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>BsmtCond</th>
      <th>BsmtExposure</th>
      <th>BsmtFinType1</th>
      <th>BsmtFinType2</th>
      <th>BsmtQual</th>
      <th>Electrical</th>
      <th>ExterCond</th>
      <th>ExterQual</th>
      <th>Fence</th>
      <th>FireplaceQu</th>
      <th>Functional</th>
      <th>GarageCond</th>
      <th>GarageFinish</th>
      <th>GarageQual</th>
      <th>HeatingQC</th>
      <th>KitchenQual</th>
      <th>LandSlope</th>
      <th>LotShape</th>
      <th>OverallCond</th>
      <th>OverallQual</th>
      <th>PavedDrive</th>
      <th>PoolQC</th>
      <th>Utilities</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1423</td>
      <td>1422</td>
      <td>1423</td>
      <td>1422</td>
      <td>1423</td>
      <td>1459</td>
      <td>1460</td>
      <td>1460</td>
      <td>281</td>
      <td>770</td>
      <td>1460</td>
      <td>1379</td>
      <td>1379</td>
      <td>1379</td>
      <td>1460</td>
      <td>1460</td>
      <td>1460</td>
      <td>1460</td>
      <td>1460</td>
      <td>1460</td>
      <td>1460</td>
      <td>7</td>
      <td>1460</td>
    </tr>
    <tr>
      <th>unique</th>
      <td>4</td>
      <td>4</td>
      <td>6</td>
      <td>6</td>
      <td>4</td>
      <td>5</td>
      <td>5</td>
      <td>4</td>
      <td>4</td>
      <td>5</td>
      <td>7</td>
      <td>5</td>
      <td>3</td>
      <td>5</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>4</td>
      <td>9</td>
      <td>10</td>
      <td>3</td>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>mode</th>
      <td>TA</td>
      <td>No</td>
      <td>Unf</td>
      <td>Unf</td>
      <td>TA</td>
      <td>SBrkr</td>
      <td>TA</td>
      <td>TA</td>
      <td>MnPrv</td>
      <td>Gd</td>
      <td>Typ</td>
      <td>TA</td>
      <td>Unf</td>
      <td>TA</td>
      <td>Ex</td>
      <td>TA</td>
      <td>Gtl</td>
      <td>Reg</td>
      <td>5</td>
      <td>5</td>
      <td>Y</td>
      <td>Gd</td>
      <td>AllPub</td>
    </tr>
    <tr>
      <th>freq</th>
      <td>1311</td>
      <td>953</td>
      <td>430</td>
      <td>1256</td>
      <td>649</td>
      <td>1334</td>
      <td>1282</td>
      <td>906</td>
      <td>157</td>
      <td>380</td>
      <td>1360</td>
      <td>1326</td>
      <td>605</td>
      <td>1311</td>
      <td>741</td>
      <td>735</td>
      <td>1382</td>
      <td>925</td>
      <td>821</td>
      <td>397</td>
      <td>1340</td>
      <td>3</td>
      <td>1459</td>
    </tr>
  </tbody>
</DataFrame>

```python
ordinal_vars = ['BsmtCond', 'BsmtQual', 'ExterQual', 'ExterCond',  'FireplaceQu', 'GarageCond',
                'GarageQual', 'HeatingQC', 'KitchenQual', 'LandSlope', 'OverallCond',
                'OverallQual']
frame_ordinal = X_train[ordinal_vars].copy()
Bsmt_Fireplace_Garage_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}
Exter_Heating_Kitchen_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}
LandSlope_mapping = {'Gtl': 2, 'Mod': 1, 'Sev': 0}
frame_ordinal['BsmtCond'] = frame_ordinal['BsmtCond'].map(Bsmt_Fireplace_Garage_mapping)
frame_ordinal['BsmtQual'] = frame_ordinal['BsmtQual'].map(Bsmt_Fireplace_Garage_mapping)
frame_ordinal['ExterQual'] = frame_ordinal['ExterQual'].map(Exter_Heating_Kitchen_mapping)
frame_ordinal['ExterCond'] = frame_ordinal['ExterCond'].map(Exter_Heating_Kitchen_mapping)
frame_ordinal['FireplaceQu'] = frame_ordinal['FireplaceQu'].map(Bsmt_Fireplace_Garage_mapping)
frame_ordinal['GarageCond'] = frame_ordinal['GarageCond'].map(Bsmt_Fireplace_Garage_mapping)
frame_ordinal['GarageQual'] = frame_ordinal['GarageQual'].map(Bsmt_Fireplace_Garage_mapping)
frame_ordinal['HeatingQC'] = frame_ordinal['HeatingQC'].map(Exter_Heating_Kitchen_mapping)
frame_ordinal['KitchenQual'] = frame_ordinal['KitchenQual'].map(Exter_Heating_Kitchen_mapping)
frame_ordinal['LandSlope'] = frame_ordinal['LandSlope'].map(LandSlope_mapping)
plot_univariate(frame_ordinal, ordinal_vars, 1.6, 3, 3, 2, sns.barplot)
```

<Image alt="Ordinal variables bar plots" src="/images/ames-housing-prices-eda/output_24_0.png" width={1268} height={836} />

- Most of the properties are nearly flat (gentle land slope). This may obviously be due to the neighborhood or area where they have been built. However, there may be some exceptions that may distinguish the houses among others in the same area.

Some other possible distinctions are houses that have different ratings in `OverallQual` or in `OverallCond` or different `LotArea` within the same neighborhood.

Since these differences might result in an increase or decrease of the price, we might need to create some features to explain this information in case our model wasn't able to capture or explain this proportion of variance in the response.

For example, outliers and patterns after plotting the residuals once the model is fit since this might indicate a deficiency in the analysis, such as a missing feature.

### Bivariate analysis

The plots below help us to identify some observations that are out of the general trend of the rest of the data in each of the predictor and target spaces.

For example, we know from the box plot of `GrLivArea` that it contains observations over the max whisker reach, i.e., with extreme value in the predictor space, but now, as we can see below, we can say that two out of this four suspected outliers are true outliers, in the sense that they do not follow the general trend of the data.

Another clear example is the property with over 6000 sf of basement in `TotalBsmtSF`, which by the price might be one of the previously defined outliers.

On the other hand, the other two observations in `GrLivArea` with more than 4000 sf are in accordance with the rest of the points or, at least, we could say they follow the trend of the rest of the houses.

```python
# Ratio-measured variables and 'SalePrice'
plot_bivariate(X_train, 'SalePrice', ratio_vars, 2.8, 3, 5, 2, plt.scatter)
```

<Image alt="Ratio variables scatter plots" src="/images/ames-housing-prices-eda/output_26_0.png" width={2101} height={1021} />

```python
# Interval-measured variables and 'SalePrice'
plot_bivariate(X_train, 'SalePrice', interval_vars, 2.2, 2, 6, 2, plt.scatter)
```

<Image alt="Interval variables scatter plots" src="/images/ames-housing-prices-eda/output_27_0.png" width={1685} height={821} />

Some houses have the same values in `YearRemodAdd` as in `YearBuilt` so they have not yet been remodeled, i.e. some of their values might have been prescriptively imputed. This may be due to the fact that the property has just been built or that it is in good condition.

However, it might not always be the case as we can see in the Series below. There are 39 properties in the training set with an `OverallCond` lower than 5 that were built the same year that the data set specifies were remodeled:

```python
pd.DataFrame(X_train[(X_train['YearRemodAdd']==X_train['YearBuilt'])&
                     (X_train['OverallCond']<5)]['OverallCond'].value_counts())
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>OverallCond</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>25</td>
    </tr>
    <tr>
      <th>3</th>
      <td>13</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
    </tr>
  </tbody>
</DataFrame>

> The creation of some features might capture information that could explain the difference of time between `YearBuilt` and `YrSold`, or between `YearBuilt` and `YearRemodAdd`, or between `YearRemodAdd` and `YrSold`. This is, there might be a pattern that could help in predicting the price.

As we can see below in both, left plot and DataFrame, the month with the lowest median of `SalePrice` is April. January, August and November are the months when there is more variability in the price of the houses being sold.

Although there are only 1460 observations in this set, we can say the first half of the year and July are when there are more properties distant from the bulk of the data, this is, perhaps this represents the type of houses that are not usually sold during the rest of the year.

Also, October does not look like the best month for real estate agents. Neither was 2008 in general.

> Although the median for 2010 is even lower than the median in 2008 there are only houses in this set until July, 2010 as was shown earlier.

```python
plot_bivariate(X_train, 'SalePrice', interval_vars2, 1.6, 2, 4, 2,
               sns.boxplot)
```

<Image alt="Interval variables box plots" src="/images/ames-housing-prices-eda/output_31_0.png" width={1124} height={260} />

```python
pd.DataFrame(X_train.groupby(['MoSold'])
             ['SalePrice'].median().sort_values().head(3))
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>SalePrice</th>
    </tr>
    <tr>
      <th>MoSold</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4.0</th>
      <td>147000.0</td>
    </tr>
    <tr>
      <th>1.0</th>
      <td>151650.0</td>
    </tr>
    <tr>
      <th>5.0</th>
      <td>154000.0</td>
    </tr>
  </tbody>
</DataFrame>

Below are boxplots of some encoded ordinal predictors against `SalePrice` . The encoding helps to understand how the order influences the sale price.

```python
# Ordinal predictors and Sale Price
# Please refer to the mapping in univariate ordinal plot in order to check the x-labels
frame_ordinal = pd.concat([frame_ordinal, X_train['SalePrice']], axis=1)
plot_bivariate(frame_ordinal, 'SalePrice', ordinal_vars, 2.2, 3, 5, 2,
               sns.boxplot)
```

<Image alt="Ordinal variables box plots" src="/images/ames-housing-prices-eda/output_34_0.png" width={2117} height={1397} />

Most of the times there is a positive correlation between the price and the ordinal predictors, however, if we take into account only the predictors that measure conditions, more is not always better, or a better condition may not translate to a higher price.

In fact, 73.84% of the first 730 most expensive houses in the set (half the dataset) have an `OverallCond` of five out of nine:

```python
series_cond = X_train.sort_values(by='SalePrice',
                                  ascending=False)['OverallCond'][:730].value_counts()
pd.DataFrame([series_cond, np.round(series_cond/series_cond.sum()*100, 2)],
             index=['n_houses', '%']).T
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>n_houses</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5</th>
      <td>539.0</td>
      <td>73.84</td>
    </tr>
    <tr>
      <th>6</th>
      <td>80.0</td>
      <td>10.96</td>
    </tr>
    <tr>
      <th>7</th>
      <td>66.0</td>
      <td>9.04</td>
    </tr>
    <tr>
      <th>8</th>
      <td>20.0</td>
      <td>2.74</td>
    </tr>
    <tr>
      <th>9</th>
      <td>13.0</td>
      <td>1.78</td>
    </tr>
    <tr>
      <th>4</th>
      <td>8.0</td>
      <td>1.10</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>0.41</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>0.14</td>
    </tr>
  </tbody>
</DataFrame>

Or we can also say that 93% of the houses with an `OverallQual` of 9 or higher have been rated with an `OverallCond` of 5 out of 9:

```python
series_cond = X_train[X_train['OverallQual']>8]['OverallCond'].value_counts()
pd.DataFrame([series_cond, np.round(series_cond/series_cond.sum()*100, 2)],
             index=['n_houses', '%']).T
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>n_houses</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5</th>
      <td>57.0</td>
      <td>93.44</td>
    </tr>
    <tr>
      <th>9</th>
      <td>2.0</td>
      <td>3.28</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1.0</td>
      <td>1.64</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>1.64</td>
    </tr>
  </tbody>
</DataFrame>

As we can see below, and as expected, the price of the properties fluctuates greatly depending on the neighborhood and also on the type of dwelling (`MSSubClass`) amongst others. For instance, 1 square feet is very differently rated in _StoneBr_ as it is in _IDOTRR_.

```python
# Nominal predictors and Sale Price
plot_bivariate(X_train, 'SalePrice', nominal_vars, 2.6, 3, 5, 2, sns.boxplot,
               labels_thresh=7, rotation=60)#rotation=70)
```

<Image alt="Nominal variables box plots" src="/images/ames-housing-prices-eda/output_40_0.png" width={2094} height={1450} />

We can see on the following table the prices per square feet on average in the most expensive and cheapest neighborhoods (considering only the price per square feet of the living area):

```python
X_train['Living_Area_'] = X_train['GrLivArea'] + X_train['TotalBsmtSF']
dollar_sf = X_train.groupby(['Neighborhood'])['Living_Area_',
                                              'SalePrice'].apply(lambda x: np.round(x.mean(), 2))
dollar_sf['$/SF'] = np.round(dollar_sf['SalePrice'] / dollar_sf['Living_Area_'], 2)
display(dollar_sf.sort_values('$/SF', ascending=False).head(2))
display(dollar_sf.sort_values('$/SF', ascending=False).tail(2))
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>Living_Area_</th>
      <th>SalePrice</th>
      <th>$/SF</th>
    </tr>
    <tr>
      <th>Neighborhood</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>StoneBr</th>
      <td>3402.08</td>
      <td>310499.00</td>
      <td>91.27</td>
    </tr>
    <tr>
      <th>NridgHt</th>
      <td>3518.78</td>
      <td>316270.62</td>
      <td>89.88</td>
    </tr>
  </tbody>
</DataFrame>

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th>Living_Area_</th>
      <th>SalePrice</th>
      <th>$/SF</th>
    </tr>
    <tr>
      <th>Neighborhood</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>SWISU</th>
      <td>2648.32</td>
      <td>142591.36</td>
      <td>53.84</td>
    </tr>
    <tr>
      <th>IDOTRR</th>
      <td>1889.14</td>
      <td>100123.78</td>
      <td>53.00</td>
    </tr>
  </tbody>
</DataFrame>

If we group by type of dwelling as well as neighborhood we can even see a bigger difference:

```python
dollar_sf = X_train.groupby(['Neighborhood',
                             'MSSubClass'])['Living_Area_',
                                            'SalePrice'].apply(lambda x: np.round(x.mean(), 2))
dollar_sf['$/SF'] = np.round(dollar_sf['SalePrice'] / dollar_sf['Living_Area_'], 2)
display(dollar_sf.sort_values('$/SF', ascending=False).head(2))
display(dollar_sf.sort_values('$/SF', ascending=False).tail(2))
```

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Living_Area_</th>
      <th>SalePrice</th>
      <th>$/SF</th>
    </tr>
    <tr>
      <th>Neighborhood</th>
      <th>MSSubClass</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowSpan="2" valign="top">
        StoneBr
      </th>
      <th>60</th>
      <td>4316.00</td>
      <td>444056.0</td>
      <td>102.89</td>
    </tr>
    <tr>
      <th>20</th>
      <td>3662.29</td>
      <td>373885.0</td>
      <td>102.09</td>
    </tr>
  </tbody>
</DataFrame>

<DataFrame>
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Living_Area_</th>
      <th>SalePrice</th>
      <th>$/SF</th>
    </tr>
    <tr>
      <th>Neighborhood</th>
      <th>MSSubClass</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>IDOTRR</th>
      <th>20</th>
      <td>1272.0</td>
      <td>45652.0</td>
      <td>35.89</td>
    </tr>
    <tr>
      <th>Edwards</th>
      <th>60</th>
      <td>6021.0</td>
      <td>167412.5</td>
      <td>27.80</td>
    </tr>
  </tbody>
</DataFrame>

On average, the price of a square feet of a 2-story dwelling in _Edwards_ is 5 times cheaper than it is in _StoneBr_. This is only an approximation for the sake of illustration since many other features in the set have an influence -to some extent- on the price of the square feet.

This is further explored in this [supervised analysis](/blog/ames-housing-prices-models 'Predicting Ames Housing Prices: Pipeline Workflow').
